/* Gil Moskowitz, 2014
   Parse MetaSQL with pegjs - http://pegjs.majda.cz

TODO:
  break
  continue
 */

{
  var params = {byCust:       true
              , startDate: '2015-03-01'
              , endDate: '2015-03-31'
              , credit: true
              , isReport: true
              , return: 'foo'
            //, byProdcat:    true
            //, byItem:       true
              , period_id_list:     [1, 2, 3, 4, 5]
            //, salesDollars:       true
            //, baseCurrAbbr:       'USD'
            //, capacityUnits:      'EA'
            //, altCapacityUnits:   'CS'
            //, inventoryUnits:     'DZ'
            //, custgrp:            true
            //, prodcategory:       true
              , item_id:            5
            //, cust_id:            4
            //, custtype_id:        3
            //, custtype_pattern:   'A[lL][lL]'
            //, prodcat_id:         2
            //, prodcat_pattern:    '[sS].*[aA]'
            //, custgrp_pattern:    'b'
            //, warehous_id:        1
      }
    , queryDef = {group: ""
                , name:  ""
                , notes: ""
      }
    , mqloptions = {valuesub:    true
                  , literalwrap: true
      }
    , loopstack = []
    , stackIdx = function(id) {
        var idx = 1;
        if (loopstack.length > 0) {
          for (idx = 0; idx < loopstack.length; idx++) {
            if (loopstack[idx].id === id) {
              break;
            }
          }
        }
        return idx;
      }
  ;
}

start
  = text:querytext ';'*
    {
      var result = '';

      if (queryDef.group && queryDef.name) {
        result = '/*\n   group: ' + queryDef.group
                 + '\n   name:  ' + queryDef.name
                 + '\n   notes: ' + queryDef.notes
                 + '\n */\n';
      }

      result += text;
      return result;
    }

querytext
  = linecomment+  ws? t2:(querytext*)           { return t2.join('') }
  / t1:sqltext    ws? t2:(querytext*)           { return t1 + t2.join('') }
  / t1:mqlclause  ws? t2:(querytext*)           { return t1 + t2.join('') }
  / BLOCKCOMMENT+ ws? t2:(querytext*)           { return t2.join('') }

sqltext
  = ws? text:(sqlpattern) { return text.join(''); }
  / ws? "<" text:(sqlpattern) { return "<" + text.join(''); }
  / ws? ">" text:(sqlpattern) { return ">" + text.join(''); }
  / ws? "<>" text:(sqlpattern) { return "<>" + text.join(''); }

sqlpattern
  = [a-zA-Z0-9,/.\-\+_*=\'\":()~ \t\n;]+

ws
  = [ \t\n\r]+

mqlclause
  = ws? value:mqlvalue          { return value; }
  / ws? literal:mqlliteral      { return literal; }
  / ws? ifcond:mqlif iftext:querytext
    elifcond:(cond:mqlelseif text:querytext)*
    mqlelse elsetext:querytext?
    mqlendif
    {
      if (ifcond) {
        return iftext;
      }
      if (elifcond !== null) {
        for (var i = 0; i < elifcond.length; i++) {
          if (elifcond[i].cond) {
            return elifcond[i].text;
          }
        }
      }
      return elsetext;
    }
  / ws? ifcond:mqlif iftext:querytext
    elifcond:(cond:mqlelseif text:querytext)*
    mqlendif
    {
      if (ifcond) {
        return iftext;
      }
      if (elifcond !== null) {
        for (var i = 0; i < elifcond.length; i++) {
          if (elifcond[i].cond) {
            return elifcond[i].text;
          }
        }
      }
      return '';
    }
  / ws? start:mqlforeach content:querytext? finish:mqlendforeach
    {
      var result = '',
          find = ":" + start;
          re = new RegExp(find, 'g');
          stackidx = stackIdx(start);
      for (var i = 0; i < params[start].length; i++) {
        result += content.replace(re, params[start][i]) + "\n";
        loopstack[stackidx].count++;
      }
      loopstack.shift().id;
      return result;
    }

mqlvalue
  = MQLOPEN ws? VALUE ws? '(' ws? id:quotedidentifier ws? ')' ws? MQLCLOSE
    {
      var stackidx, listidx;
      if (Object.prototype.toString.call(params[id]) === '[object Array]') {
        stackidx = stackIdx(id);
        if (stackidx < loopstack.length) {
          listidx = loopstack[stackidx].count;
          if (listidx >= params[id].length) {
            listidx = params[id].length - 1;
          }

          if (typeof params[id][0] == 'string') {
            return ("'" + ':' + id + "'");
          } else {
            return (':' + id);
          }
        }
        else {
          if (typeof params[id][0] == 'string') {
            return ("'" + ':' + id + "'");
          } else {
            return (':' + id);
          }
        }
      }

      if (typeof params[id] == 'string') {
        return mqloptions.valuesub ? ("'" + params[id] + "'") : ("'" + ':' + id + "'");
      } else {
        return mqloptions.valuesub ? (params[id]) : (':' + id);
      }
    }

mqlliteral
  = MQLOPEN ws? LITERAL ws? '(' ws? id:quotedidentifier ws? ')' ws? MQLCLOSE
    { var wrap = mqloptions.literalwrap ? '"' : '';
      return (wrap + params[id] + wrap);
    }

linecomment
  = groupcomment
  / namecomment
  / notescomment
  / simplelinecomment

mqlif
  = MQLOPEN ws? IF ws? cond:mqlcondition ws? MQLCLOSE           { return cond; }

mqlelseif
  = MQLOPEN ws? ELSEIF ws? cond:mqlcondition ws? MQLCLOSE       { return cond; }

mqlelse
  = MQLOPEN ws? ELSE ws? MQLCLOSE

mqlendif
  = MQLOPEN ws? ENDIF ws? MQLCLOSE

mqlforeach
  = MQLOPEN ws? FOREACH ws? '(' ws? id:quotedidentifier ws? ')' ws? MQLCLOSE
    { loopstack.unshift({ id: id, count: 0 }); return id; }

mqlendforeach
  = MQLOPEN ws? ENDFOREACH ws? MQLCLOSE { return ''; }

mqlcondition
  = NOT ws+ EXISTS ws? '(' ws? id:quotedidentifier ws? ')'
    { return ! (id in params); }
  / EXISTS ws? '(' ws? id:quotedidentifier ws? ')'
    { return (id in params); }
  / REEXISTS ws? '(' ws? re:regexp ws? ')'
    {
      for (var prop in params) {
        if (prop.match(re)) {
          return true;
        }
      }
      return false;
    }
  / ISFIRST ws? '(' ws? id:quotedidentifier ws? ')'
    { return loopstack[stackIdx(id)].count === 0; }
  / ISLAST  ws? '(' ws? id:quotedidentifier ws? ')'
    { return loopstack[stackIdx(id)].count >= params[id].length; }

groupcomment
  = ws? '--' [ \t]? [Gg][Rr][Oo][Uu][Pp] [ \t]? ':' [ \t]? id:identifier [ \t]? '\n' { queryDef.group = id; }

namecomment
  = ws? '--' [ \t]? [Nn][Aa][Mm][Ee]     [ \t]? ':' [ \t]? id:identifier [ \t]? '\n' { queryDef.name = id; }

notescomment
  = ws? '--' [ \t]? [Nn][Oo][Tt][Ee][Ss] [ \t]? ':' content:([^\n]*)? '\n'
    rest:(simplelinecomment*)
    { queryDef.notes = rest.join(' '); }

simplelinecomment
  = ws? '--' ws? content:([^\n]*) '\n'  { return content.join(""); }

quotedidentifier
  = '"' id:identifier '"'               { return id; }
  / "'" id:identifier "'"               { return id; }

regexp
  = "'" str:([^']*) "'"                 { return str.join(""); }
  / '"' str:([^"]*) '"'                 { return str.join(""); }

identifier
  = first:[a-zA-Z_] rest:[a-zA-Z0-9_]*  { return first + rest.join(""); }

VALUE      = [Vv] [Aa] [Ll] [Uu] [Ee]
LITERAL    = [Ll] [Ii] [Tt] [Ee] [Rr] [Aa] [Ll]
IF         = [Ii] [Ff]
ELSEIF     = [Ee] [Ll] [Ss] [Ee] [Ii] [Ff]
ELSE       = [Ee] [Ll] [Ss] [Ee]
ENDIF      = [Ee] [Nn] [Dd] [Ii] [Ff]
NOT        = [Nn] [Oo] [Tt]
EXISTS     = [Ee] [Xx] [Ii] [Ss] [Tt] [Ss]
REEXISTS   = [Rr] [Ee] [Ee] [Xx] [Ii] [Ss] [Tt] [Ss]
ISFIRST    = [Ii] [Ss] [Ff] [Ii] [Rr] [Ss] [Tt]
ISLAST     = [Ii] [Ss] [Ll] [Aa] [Ss] [Tt]
FOREACH    = [Ff] [Oo] [Rr] [Ee] [Aa] [Cc] [Hh]
ENDFOREACH = [Ee] [Nn] [Dd] [Ff] [Oo] [Rr] [Ee] [Aa] [Cc] [Hh]

BLOCKCOMMENT = '/*' [.*] '*/'
MQLOPEN      = '<?'
MQLCLOSE     = '?>'
